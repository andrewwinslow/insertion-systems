/*
Author: Andrew Winslow (andrewwinslow@gmail.com)

Program for converting a symbol-pair grammar to an insertion system
that expresses it, following the algorithm described in the proof 
of Lemma 3.3 of http://arxiv.org/abs/1401.0359

The program takes a symbol-pair grammar from stdin
and prints the resulting insertion system to stdout.
The output symbol-pair grammar can be used as input to simulator.

The input grammar must consist of lines (delimited by '\n'),
each with one of three forms:
1. "# ..." (a comment) or " " (whitespace).
2. "(1, 2) -> (1, 3) (4, 1)" (an integer 2-tuple followed by "->" 
                              followed by two integer 2-tuples whose 
                              first and last letters match those of
                              the first 2-tuple.)
3. "(1, 2) -> a" (an integer 2-tuple number followed by "->" 
                  followed by a letter.) 
The order of the lines does not matter.
*/

#include <stdlib.h>
#include <stdio.h>
#include "pairgrammar.h"

#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))

void clean(char buf[]) {
	int i;
	for(i = 0; i < BUFSIZ && buf[i] != '\0'; i++) {
		// Comments
		if(buf[i] == '#') 
			buf[i] = '\0';
		// Right arrows
		else if(buf[i] == '-' || buf[i] == '>')
			buf[i] = ' ';
		// Tuple cruft 
 		else if (buf[i] == ',' || buf[i] == '(' || buf[i] == ')')
			buf[i] = ' ';
	}	
}

int main() {
	PairGrammar* pg = malloc(sizeof(PairGrammar));
	initialize_pair_grammar(pg);

	char buf[BUFSIZ];
	Rule tempRule;
	while (fgets(buf, sizeof buf, stdin)) {
		clean(buf);		

		// Try to read the line as a (a, d) -> (a, b) (c, d) rule
		if (sscanf(buf,"%d %d %d %d %d %d", &tempRule.lhs.a, &tempRule.lhs.d, 
			&tempRule.rhs1.a, &tempRule.rhs1.d, &tempRule.rhs2.a, &tempRule.rhs2.d) == 6) {
			tempRule.is_terminal = false;	
			if (!rule_is_valid(&tempRule)) {
				fprintf(stderr, "Line was parsed as (%d, %d) -> (%d, %d) (%d, %d), an invalid rule:\n	%s\n",
					tempRule.lhs.a, tempRule.lhs.d, tempRule.rhs1.a, tempRule.rhs1.d,
					tempRule.rhs2.a, tempRule.rhs2.d, buf); 
				return EXIT_FAILURE;
			}
			add_rule_to_pair_grammar(tempRule, pg); 
			continue;
		}

		// Try to read the line as a (a, d) -> s rule
		if (sscanf(buf,"%d %d %c", &tempRule.lhs.a, &tempRule.lhs.d, &tempRule.rhsTerm) == 3) {
			tempRule.is_terminal = true;
			if (!rule_is_valid(&tempRule)) {
				fprintf(stderr, "Line was parsed as (%d, %d) -> %c, an invalid rule:\n	%s\n",
					tempRule.lhs.a, tempRule.lhs.d, tempRule.rhsTerm, buf);
				return EXIT_FAILURE;
			}
			add_rule_to_pair_grammar(tempRule, pg); 
			continue;
		}	

		// Try to read the line as a start symbol (a, d)
		if (sscanf(buf, "%d %d", &tempRule.lhs.a, &tempRule.lhs.d) == 2) {
			if (pg->has_start) {
				fprintf(stderr, "Line was parsed as (%d, %d), but pair grammar already has a start symbol:\n	%s\n",
					tempRule.lhs.a, tempRule.lhs.d, buf);
				return EXIT_FAILURE;
			}
			set_start(tempRule.lhs, pg);
			continue;
		}

		if (sscanf(buf, "%d", &tempRule.lhs.a) != EOF)
		{
			fprintf(stderr, "Line has stuff but can't be parsed:\n	%s\n", buf);
			return EXIT_FAILURE;
		}	

	}

	// Check that the resulting grammar is valid globally (something we can't do line by line)
	if (!pair_grammar_is_valid(pg)) {
		fprintf(stderr, "Pair grammar is not valid.\n");
		return EXIT_FAILURE;
	}

	// Compute ranges of the indices in all non-terminals, so we can shift lots of things
	// to avoid collisions in the positive integer based monomer world.
	int min_pg_index = MIN(pg->start.a, pg->start.d);
	int max_pg_index = MAX(pg->start.a, pg->start.d);
	for (unsigned int i = 0; i < pg->rule_count; ++i) {
		Rule* r = &pg->rules[i];
		if (r->is_terminal) {
			min_pg_index = MIN(MIN(min_pg_index, r->lhs.a), r->lhs.d);
			max_pg_index = MAX(MAX(max_pg_index, r->lhs.a), r->lhs.d);
		}
		else {
			min_pg_index = MIN(MIN(MIN(MIN(MIN(MIN(min_pg_index, r->lhs.a), r->lhs.d), r->rhs1.a), 
				r->rhs1.d), r->rhs2.a), r->rhs2.d);
			max_pg_index = MAX(MAX(MAX(MAX(MAX(MAX(max_pg_index, r->lhs.a), r->lhs.d), r->rhs1.a), 
				r->rhs1.d), r->rhs2.a), r->rhs2.d);
		}
	}

	// Shift the non-terminal indices to be positive
	pg->start.a += -min_pg_index + 1;
	pg->start.d += -min_pg_index + 1;	
	for (unsigned int i = 0; i < pg->rule_count; ++i) {
		Rule* r = &pg->rules[i];
		r->lhs.a += -min_pg_index + 1;	
		r->lhs.d += -min_pg_index + 1;	
		r->rhs1.a += -min_pg_index + 1;	
		r->rhs1.d += -min_pg_index + 1;	
		r->rhs2.a += -min_pg_index + 1;	
		r->rhs2.d += -min_pg_index + 1;	
	}	

	// Shift everything else to be positive and larger than the largest non-terminal index
	int u_index = (max_pg_index + 1) + (-min_pg_index + 1);
	int x_index = (max_pg_index + 2) + (-min_pg_index + 1);
	int terminal_shift = x_index + 1;

        fprintf(stdout, "# Insertion system generated by pg2is using algorithm from\n");
        fprintf(stdout, "# B. Hescott, C. Malchik, A. Winslow,\n");
	fprintf(stdout, "# \"Tight bounds for active self-assembly using an insertion primitive\",\n");
        fprintf(stdout, "# http://arxiv.org/abs/1401.0359\n\n");

	fprintf(stdout, "# Non-terminal integer indices range from %d to %d.\n", min_pg_index, max_pg_index);
	fprintf(stdout, "# u = %d, x = %d\n", u_index, x_index);
	fprintf(stdout, "# Terminal characters range from %d to %d.\n\n", terminal_shift, terminal_shift + 256);

	fprintf(stdout, "# Initiator for start symbol (%d, %d)\n", pg->start.a, pg->start.d);
	fprintf(stdout, "(%d, %d) (%d, %d*)\n\n", u_index, pg->start.a, pg->start.d, u_index); 

	for (unsigned int i = 0; i < pg->rule_count; ++i) { 
		Rule* r = &pg->rules[i];
		if (r->is_terminal) {
			fprintf(stdout, "# Monomers for rule (%d, %d) -> %c\n", r->lhs.a, r->lhs.d, r->rhsTerm);
			fprintf(stdout, "(%d*, %d, %d, %d*)+\n", r->lhs.a, r->rhsTerm + terminal_shift, x_index, r->lhs.d);
		} else {	
			fprintf(stdout, "# Monomers for rule (%d, %d) -> (%d, %d) (%d, %d).\n", 
				r->lhs.a, r->lhs.d, r->rhs1.a, r->rhs1.d, r->rhs2.a, r->rhs2.d);
			fprintf(stdout, "(%d, %d*, %d*, %d)-\n", r->rhs1.d, u_index, r->rhs1.d, x_index);      // Delta_1'
			fprintf(stdout, "(%d*, %d, %d*, %d*)+\n", r->rhs1.a, r->rhs1.d, r->rhs2.a, r->rhs2.d); // Delta_2'
			fprintf(stdout, "(%d, %d, %d, %d)-\n", x_index, r->rhs2.a, u_index, r->rhs2.a);     // Delta_3'
		}
		fprintf(stdout, "\n");
	}

	return EXIT_SUCCESS;
}




