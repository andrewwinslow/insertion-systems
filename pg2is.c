// Takes in a pair grammar, converts it to an insertion system
// for feeding into Caleb's simulator

#include <stdlib.h>
#include <stdio.h>
#include "pairgrammar.h"

#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))

void
clean(char buf[]) 
{
	int i;
	for(i = 0; i < BUFSIZ && buf[i] != '\0'; i++) {
		// Comments
		if(buf[i] == '#') 
			buf[i] = '\0';
		// Right arrows
		else if(buf[i] == '-' || buf[i] == '>')
			buf[i] = ' ';
		// Tuple cruft 
 		else if (buf[i] == ',' || buf[i] == '(' || buf[i] == ')')
			buf[i] = ' ';
	}	
}

int
main()
{
	PairGrammar* pg = malloc(sizeof(PairGrammar));
	initialize_pair_grammar(pg);

	char buf[BUFSIZ];
	Rule tempRule;
	while (fgets(buf, sizeof buf, stdin)) {
		clean(buf);		

		// Try to read the line as a (a, d) -> (a, b) (c, d) rule
		if (sscanf(buf,"%d %d %d %d %d %d", &tempRule.lhs.a, &tempRule.lhs.d, 
			&tempRule.rhs1.a, &tempRule.rhs1.d, &tempRule.rhs2.a, &tempRule.rhs2.d) == 6) {
			tempRule.is_terminal = false;	
			if (!rule_is_valid(&tempRule)) {
				fprintf(stderr, "Line was parsed as (%d, %d) -> (%d, %d) (%d, %d), an invalid rule:\n	%s\n",
					tempRule.lhs.a, tempRule.lhs.d, tempRule.rhs1.a, tempRule.rhs1.d,
					tempRule.rhs2.a, tempRule.rhs2.d, buf); 
				return EXIT_FAILURE;
			}
			add_rule_to_pair_grammar(tempRule, pg); 
			continue;
		}

		// Try to read the line as a (a, d) -> s rule
		if (sscanf(buf,"%d %d %c", &tempRule.lhs.a, &tempRule.lhs.d, &tempRule.rhsTerm) == 3) {
			tempRule.is_terminal = true;
			if (!rule_is_valid(&tempRule)) {
				fprintf(stderr, "Line was parsed as (%d, %d) -> %c, an invalid rule:\n	%s\n",
					tempRule.lhs.a, tempRule.lhs.d, tempRule.rhsTerm, buf);
				return EXIT_FAILURE;
			}
			add_rule_to_pair_grammar(tempRule, pg); 
			continue;
		}	

		// Try to read the line as a start symbol (a, d)
		if (sscanf(buf, "%d %d", &tempRule.lhs.a, &tempRule.lhs.d) == 2) {
			if (pg->has_start) {
				fprintf(stderr, "Line was parsed as (%d, %d), but pair grammar already has a start symbol:\n	%s\n",
					tempRule.lhs.a, tempRule.lhs.d, buf);
				return EXIT_FAILURE;
			}
			set_start(tempRule.lhs, pg);
			continue;
		}

		if (sscanf(buf, "%d", &tempRule.lhs.a) != EOF)
		{
			fprintf(stderr, "Line has stuff but can't be parsed:\n	%s\n", buf);
			return EXIT_FAILURE;
		}	

	}

	// Check that the resulting grammar is valid globally (something we can't do line by line)
	if (!pair_grammar_is_valid(pg))
	{
		fprintf(stderr, "Pair grammar is not valid.\n");
		return EXIT_FAILURE;
	}

	// Compute ranges of the indices in all non-terminals, so we can shift lots of things
	// to avoid collisions in the positive integer based monomer world.
	int min_pg_index = MIN(pg->start.a, pg->start.d);
	int max_pg_index = MAX(pg->start.a, pg->start.d);
	for (unsigned int i = 0; i < pg->rule_count; ++i) {
		Rule* r = &pg->rules[i];
		if (r->is_terminal) {
			min_pg_index = MIN(MIN(min_pg_index, r->lhs.a), r->lhs.d);
			max_pg_index = MAX(MAX(max_pg_index, r->lhs.a), r->lhs.d);
		}
		else {
			min_pg_index = MIN(MIN(MIN(MIN(MIN(MIN(min_pg_index, r->lhs.a), r->lhs.d), r->rhs1.a), 
				r->rhs1.d), r->rhs2.a), r->rhs2.d);
			max_pg_index = MAX(MAX(MAX(MAX(MAX(MAX(max_pg_index, r->lhs.a), r->lhs.d), r->rhs1.a), 
				r->rhs1.d), r->rhs2.a), r->rhs2.d);
		}
	}

	// Shift the non-terminal indices to be positive
	pg->start.a += -min_pg_index + 1;
	pg->start.d += -min_pg_index + 1;	
	for (unsigned int i = 0; i < pg->rule_count; ++i) {
		Rule* r = &pg->rules[i];
		r->lhs.a += -min_pg_index + 1;	
		r->lhs.d += -min_pg_index + 1;	
		r->rhs1.a += -min_pg_index + 1;	
		r->rhs1.d += -min_pg_index + 1;	
		r->rhs2.a += -min_pg_index + 1;	
		r->rhs2.d += -min_pg_index + 1;	
	}	

	// Shift everything else to be positive and larger than the largest non-terminal index
	int u_index = (max_pg_index + 1) + (-min_pg_index + 1);
	int v_index = (max_pg_index + 2) + (-min_pg_index + 1);
	int terminal_shift = v_index + 1;
	for (unsigned int i = 0; i < pg->rule_count; ++i) {
		pg->rules[i].rhsTerm += terminal_shift;
	} 

	fprintf(stdout, "# Insertion simulation generated by pg2is using Winslow paper algorithm.\n\n");
	fprintf(stdout, "# Specific information:\n");
	fprintf(stdout, "# Non-terminal integer indices range from %d to %d.\n", min_pg_index, max_pg_index);
	fprintf(stdout, "# u = %d, u* = %d*.\n", u_index, u_index);
	fprintf(stdout, "# v = %d, v* = %d*.\n", v_index, v_index);
	fprintf(stdout, "# Terminal characters range from %d to %d.\n\n", terminal_shift, terminal_shift + 256);

	fprintf(stdout, "# Initiator\n");
	fprintf(stdout, "(%d*, %d*)(%d, %d)\n\n", v_index, pg->start.a, pg->start.d, v_index); 

	for (unsigned int i = 0; i < pg->rule_count; ++i) { 
		Rule* r = &pg->rules[i];
		if (r->is_terminal) {
			fprintf(stdout, "# Monomers for rule (%d, %d) -> %c\n", r->lhs.a, r->lhs.d, r->rhsTerm);
			fprintf(stdout, "(%d, %d, %d, %d*)+\n", r->lhs.a, r->rhsTerm + terminal_shift, u_index, r->lhs.d);
		} else {	
			fprintf(stdout, "# Monomers for rule (%d, %d) -> (%d, %d) (%d, %d).\n", 
				r->lhs.a, r->lhs.d, r->rhs1.a, r->rhs1.d, r->rhs2.a, r->rhs2.d);
			fprintf(stdout, "(%d, %d, %d*, %d)-\n", r->rhs1.d, v_index, r->rhs1.d, u_index);
			fprintf(stdout, "(%d, %d, %d*, %d*)+\n", r->rhs1.a, r->rhs1.d, r->rhs2.a, r->rhs2.d);
			fprintf(stdout, "(%d, %d, %d*, %d*)-\n", u_index, r->rhs2.a, v_index, r->rhs2.a);
		}
		fprintf(stdout, "\n");
	}

	return EXIT_SUCCESS;
}




